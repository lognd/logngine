from pathlib import Path
from typing import Dict, Any, List, Tuple
import random

try:
    import numpy as np
    from rtree import index
    from tqdm import tqdm
except ImportError:
    raise ImportError("Install logngine[dev] to use SourceBaker: `pip install logngine[dev]`")

from .SVUVParser import SVUVParser


class SourceBaker:

    CITATION_PATH: str = 'data/citations.h'
    citations: list[str] = []

    def __init__(self, file: str | Path):
        self.parser = SVUVParser()
        self.data = self.parser.read(file)

        best_order = self.get_best_insertion_order()
        print(f"Best order found (by index): {best_order}")
        self.shuffle_data_to_best_order(best_order)

    def shuffle_data_to_best_order(self, ordering: List[int]) -> Dict[str, List[Any]]:
        data_out = {k: [] for k in self.data}
        for key in data_out:
            data_out[key] = [self.data[key][i] for i in ordering]
        self.data = data_out
        return data_out

    def get_best_insertion_order(self) -> List[int]:
        best_ordered, _ = self.find_best_order(self.convert_to_dataset(self.data))
        return [int(label) for _, label in best_ordered]

    def write_to_source_file(self, path: Path | str, data_namespace: str, dataset_name: str):
        for citation in self.data['$citation']:
            if citation not in SourceBaker.citations: SourceBaker.citations.append(citation)

        # Generate citation index that will be referenced by all source files
        src = ("// Automatically generated by SourceBaker.py\n"
        "#pragma once\n\n"
        "#include <string>"
        "#include <logngine/core/RSTTree.h>\n"
        "namespace logngine::data::citation{\n"
        "    const std::string[] CITATION_INDEX = {")
        for citation in SourceBaker.citations:
            src += f"    \"{citation}\""
        src += ("    }"
                "}\n")
        with open(SourceBaker.CITATION_PATH, 'W+') as f:
            f.write(src)

        # Write RTree-indexed file.
        path = Path(path).resolve()
        data_headers = [hdr for hdr in self.data if '$' not in hdr]

        region_data = [row for row in zip(*[self.data[hdr] for hdr in data_headers])]
        sorted_headers = data_headers.copy()
        sorted_headers += [f'{hdr}$uncertainty' for hdr in sorted_headers]
        full_data = [row + [SourceBaker.citations.index(cite)] for *row, cite in zip(*[self.data[hdr] for hdr in sorted_headers], '$citation')]

        src = "// Automatically generated by SourceBaker.py\n"
        "#pragma once\n\n"
        "#include <logngine/core/RSTTree.h>\n"
        f"namespace logngine::data::{data_namespace}{{\n"
        "    "
        f"    RSTTree<{len(data_headers)}, 16, 16, >"
        for region_dat, full_dat in zip(region_data, full_data):

        src += "}\n"

    @staticmethod
    def convert_to_dataset(raw_dataset: Dict[str, List[Any]]) -> List[Tuple[Tuple[List[float], List[float]], str]]:
        headers = []
        values = []
        for header, column in raw_dataset.items():
            if '$' in header: continue
            headers.append(header)
            values.append(column)

        dataset = []
        for i, row in enumerate(zip(*values)):
            point = list(row)
            dataset.append(((point, point), str(i)))
        return dataset

    @staticmethod
    def mbr_area(bbox: List[float]) -> float:
        d = len(bbox) // 2
        return np.prod([bbox[d + i] - bbox[i] for i in range(d)])

    @staticmethod
    def compute_total_overlap(idx: index.Index) -> float:
        overlaps = 0.0
        for i in idx.intersection(idx.bounds, objects=True):
            for j in idx.intersection(i.bbox, objects=True):
                if i.id >= j.id:
                    continue
                dims = len(i.bbox) // 2
                intersection = [max(i.bbox[k], j.bbox[k]) for k in range(dims)] + \
                               [min(i.bbox[k + dims], j.bbox[k + dims]) for k in range(dims)]
                if all(intersection[k] < intersection[k + dims] for k in range(dims)):
                    overlaps += SourceBaker.mbr_area(intersection)
        return overlaps

    @staticmethod
    def evaluate_tree(entries: List[Tuple[Tuple[List[float], List[float]], str]]) -> Tuple[float, float]:
        p = index.Property()
        p.dimension = len(entries[0][0][0])
        idx = index.Index(properties=p)

        for i, (bbox, _) in enumerate(entries):
            min_corner, max_corner = bbox
            flat_bbox = tuple(min_corner + max_corner)
            assert len(flat_bbox) == 2 * p.dimension, "Bounding box dimension mismatch."
            idx.insert(i, flat_bbox)

        total_area = sum(SourceBaker.mbr_area(obj.bbox) for obj in idx.intersection(idx.bounds, objects=True))
        total_overlap = SourceBaker.compute_total_overlap(idx)

        return total_area, total_overlap

    @staticmethod
    def find_best_order(entries: List[Tuple[Tuple[List[float], List[float]], str]],
                        trials: int = 10000) -> Tuple[List[Tuple[Tuple[List[float], List[float]], str]], List[Tuple[float, List]]]:
        best_score = float('inf')
        best_order = []
        results = []

        for _ in tqdm(range(trials), desc="Testing insertion orders"):
            random.shuffle(entries)
            area, overlap = SourceBaker.evaluate_tree(entries)
            score = area + overlap
            results.append((score, list(entries)))
            if score < best_score:
                best_score = score
                best_order = list(entries)

        return best_order, results